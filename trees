How to create a tree -
class TreeNode{
  int val;
  TreeNode left;
  TreeNode right;
  
  TreeNode(int val){
    this.val = val;
    TreeNode left = null;
    TreeNode tight = null;
  }
}

Traversals -
DFS - inOrder, preOrder, postOrder
1.Inorder traversal (left, root, right)
2.Preorder traversal (root, left, right)
3.Post order traversal (left, right, root)
*If we have Inorder & preOrder traversals, we can construct a unique binary tree.
*If we have Inorder & postOrder traversals, we can construct a unique binary tree.
*If we have preOrder & postOrder traversals, we cannot construct a unique binary tree, we can construct multiple trees.

BFS - levelOrder

####################################################################################################################
Find height of binary tree -
public int maxHeight(TreeNode root){
  if(root == null) return 0;
  int lHeight = maxHeight(root.left);
  int rHeight = maxHeight(root.right);
  return 1+ Math.max(lHeight, rHeight);
}
Example problems on which uses Height algo -
1.Check if a binary tree is height balanced or not - At every node, lHeight and rHeight shouldn't differ by 1.
  After getting lHeight & rHeight, check if Math.abs(lHeight-rHeight) > 1 => return -1;
  If atleast one node has crossed the condition, we should continue returning -1.
public int heightBalanced(TreeNode root){
  if(root == null) return 0;
  int lHeight = maxHeight(root.left);
  if(lHeight == -1) return -1;
  int rHeight = maxHeight(root.right);
  if(rHeight == -1) return -1;
  if(Math.abs(lHeight-rHeight) > 1) return -1;
  return 1+ Math.max(lHeight, rHeight);
}

2.Diamaeter of a binary tree (max distance between any two nodes)
  For any node, diameter which passes through it - lHeight+rHeight
  *Take an array of size 1, check if we can update it for every node. This will be the ans.
public int maxDiamater(TreeNode root, int[] maxLength){
  if(root == null) return 0;
  int lHeight = maxDiamater(root.left, maxLength);
  int rHeight = maxDiamater(root.right, maxLength);
  maxLength[0] = Math.max(maxLength[0], lHeight+rHeight);
  return 1+ Math.max(lHeight, rHeight);
}
ans will be maxLength[0].

3.Max path sum (Between any two nodes, find the sum of all the nodes between the two nodes)
*The sum might not be between 2 leaf nodes as nodes can contain -ve values. But for the sum, we need all nodes to be consecutive.
public int maxSum(TreeNode root, int[] maxVal){
  if(root == null) return 0;
  int lHeight = Math.max(0, maxSum(root.left)); //to handle -ve values.
  int rHeight = Math.max(0, maxSum(root.right));
  maxVal[0] = Math.max(maxVal[0], root.val+lHeight+rHeight);
  return root.val+ Math.max(lHeight, rHeight);
}
Initialise with maxval[0] = Integer.MIN_VALUE, ans will be maxVal[0].

####################################################################################################################
Search for a node in Binary tree. Keep returning node if it is found. Else, return null.
public Node searchNode(Node root, int key){
    if(root == null) return null;
    if(root.data == key) return root;
    Node left = searchNode(root.left, key);
    if(left != null) return left;
    Node right = searchNode(root.right, key);
    if(right != null) return right;
    return null;
}
####################################################################################################################
Boundary Traversal
Vertical order Traversal
Top View
Bottom View
Right/Left View

####################################################################################################################
How to find parent for a binary tree - 
Map<TreeNode, TreeNode> - map of child & parent. Addroot to map before putting it in the map.
parentMap.put(root, null)
public void generateParentChildMap(TreeNode root, Map<TreeNode, TreeNode> parentMap){
    if(root.left != null){
        parentMap.put(root.left, root);
        generateParentChildMap(root.left, parentMap);
    }
    if(root.right != null){
        parentMap.put(root.right, root);
        generateParentChildMap(root.right, parentMap);
    }
}

Similar to graph bfs/dfs, first mark it visited and check if child/parent is visited or not before calling recursion.
We should have visited, as we are going to parent and parent will again visit node as child. So visited needs to be there for not visiting it multiple times.
public void distanceK(TreeNode root, int level, Set<Integer> visited, Map<TreeNode, TreeNode> parentMap, List<Integer> ansLst){
        if(root == null) return;
        visited.add(root.val);
        if(level == 0){
            ansLst.add(root.val);
            return;
        }
        if(root.left != null && !visited.contains(root.left.val)){
            distanceK(root.left, level-1, visited, parentMap, ansLst);
        }
        if(root.right != null && !visited.contains(root.right.val)){
            distanceK(root.right, level-1, visited, parentMap, ansLst);
        }
        if(parentMap.get(root) != null && !visited.contains(parentMap.get(root).val)){
            distanceK(parentMap.get(root), level-1, visited, parentMap, ansLst);
        }
    }

min time to burn complete tree -
public static void minTime(Node target, int level, Set<Node> visited, Map<Node, Node> parentMap, int[] maxLevel){
    if(target==null) return;
    visited.add(target);
    maxLevel[0] = Math.max(maxLevel[0], level);
    if(target.left != null && !visited.contains(target.left)){
        minTime(target.left, level+1, visited, parentMap, maxLevel);
    }
    if(target.right != null && !visited.contains(target.right)){
        minTime(target.right, level+1, visited, parentMap, maxLevel);
    }
    if(parentMap.get(target) != null && !visited.contains(parentMap.get(target))){
        minTime(parentMap.get(target), level+1, visited, parentMap, maxLevel);
    }
}
####################################################################################################################
Binary Search Trees
####################################################################################################################
Inorder Traversal of BST will be in sorted order.
To get in reverse sorted order, do right-root-left instead of left-root-right.

Search in BST -  Iterative & recursive.
1.If key is found, return
2.If root.val < requried, go to right
3.If root.val > required, go to left
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        if(root == null) return null;
        if(root.val == val) return root;
        if(root.val > val) return searchBST(root.left, val);
        return searchBST(root.right, val);
    }
}
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        while(root != null){
            if(root.val == val) return root;
            if(root.val > val) root = root.left;
            else root = root.right;
        }
        return null;
}
Min/Max value of BST - left most/ right most elements are min and max respectively.
class Solution {
    int minValue(Node root) {
        while(root.left != null){
            root = root.left;
        }
        return root.data;
    }
}
Find floor, ceil in BST - Similar to searching for element in BST.
class Tree {
    int findCeil(Node root, int key) {
        if (root == null) return -1;
        int ceil = Integer.MAX_VALUE;
        while(root != null){
            if(root.data == key) return key;
            if(root.data > key){
                ceil = Math.min(ceil, root.data);
                root = root.left;
            }else{
                root = root.right;
            }
        }
        return ceil==Integer.MAX_VALUE?-1:ceil;
    }
}
Insert element to BST -
class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        if(root == null) return new TreeNode(val);
        if(root.val > val){
            root.left = insertIntoBST(root.left, val);
        }else{
            root.right = insertIntoBST(root.right, val);
        }
        return root;
    }
}
Delete element in BST -
1.To maintain height. Swap actual value with either successor/ predecessor and delete key by going to root.right/root.left
2.Height might be very un-balanced. Connect root.right to predecessor and return root.left.
Conditions to remove node -
If it is a root node, return null;
If it has only one child, return root.left or root.right;

public TreeNode deleteNodeHeightBalanced(TreeNode root, int key){
    if(root == null) return null;
    if(root.val == key){
        if(root.left == null && root.right == null) return null;
        if(root.left == null) return root.right;
        if(root.right == null) return root.left;
        TreeNode rightMost = root.left;
        while(rightMost.right != null){
            rightMost = rightMost.right;
        }
        root.val = rightMost.val;
        rightMost.val = key;
        root.left = deleteNodeHeightBalanced(root.left, key);
        return root;
    }
    if(root.val > key){
        root.left = deleteNodeHeightBalanced(root.left, key);
    }else{
        root.right = deleteNodeHeightBalanced(root.right, key);
    }
    return root;
}
    
public TreeNode deleteNodeHeightUnbalanced(TreeNode root, int key) {
    if(root == null) return null;
    if(root.val == key){
        if(root.left == null && root.right == null) return null;
        if(root.left == null) return root.right;
        if(root.right == null) return root.left;
        TreeNode rightMost = root.left;
        while(rightMost.right != null){
            rightMost = rightMost.right;
        }
        rightMost.right = root.right;
        return root.left;
    }
    if(root.val > key){
        root.left = deleteNodeHeightUnbalanced(root.left, key);
    }else{
        root.right = deleteNodeHeightUnbalanced(root.right, key);
    }
    return root;
}

Kth smallest element in BST-
class Solution {
    public void inOrder(TreeNode root, int k, int[] cnt, int[] ans){
        if(root == null) return;
        if(ans[0] != -1) return;
        inOrder(root.left, k, cnt, ans);
        cnt[0] = cnt[0]+1;
        if(cnt[0] == k){
            ans[0] = root.val;
            return;
        }
        inOrder(root.right, k, cnt, ans);
    }
    public int kthSmallest(TreeNode root, int k) {
        int[] cnt = new int[1];
        int[] ans = new int[1];
        ans[0] = -1;
        inOrder(root, k, cnt, ans);
        return ans[0];
    }
}

Validate BST -
1.If inorder is sorted, then it is BST.
2.If root is more that root.left and less than root.right, and repeating isValidBST for left and right sub-trees will not work.
Use long instead of int, as val of nodes can be int max or min values.
class Solution {
    public boolean isValidBSTWithRange(TreeNode root, long minVal, long maxVal){
        if(root == null) return true;
        if(root.val <= minVal || root.val >= maxVal) return false;
        return isValidBSTWithRange(root.left, minVal, root.val) && isValidBSTWithRange(root.right, root.val, maxVal);
    }
    public boolean isValidBST(TreeNode root) {
        return isValidBSTWithRange(root, Long.MIN_VALUE, Long.MAX_VALUE);
    }
}

Lowest Common Ancestor - If root.val >= node1.val and root.val <= node2.val, then root is LCA.
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null) return null;
        if(root.val >= Math.min(p.val, q.val) && root.val <= Math.max(p.val, q.val)){
            return root;
        }
        if(root.val > Math.max(p.val, q.val)){
            return lowestCommonAncestor(root.left, p, q);
        }
        if(root.val < Math.min(p.val, q.val)){
            return lowestCommonAncestor(root.right, p, q);
        }
        return null;
    }
}

