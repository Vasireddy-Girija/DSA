heaps - minHeap, maxHeap
complete binary tree - So we can represent it as an array. And this array will have no null/empty values.
parent - i, left child - 2*i+1, right child - 2*i+2
parent for child i - (i-1)/2
operations - shiftUp, shiftDown(heapify), insert, extractMin, extractMax, delete, heapSort, createHeap
leaf nodes - (n-2)/2 to n-1 (check this)

Priority Queue - used to implement heaps (by default, it is a minHeap)
PriorityQueue<Integer> pq = new PriorityQueue<>();
PriorityQueue<Integer> pq = new PriorityQueue<>(int capacity);
PriorityQueue<Integer> pq = new PriorityQueue<>(int capacity, Comparator);
PriorityQueue<Integer> pq = new PriorityQueue<>(Collections); 
pq.add(), pq.poll(), pq.peek() for adding, deleting and first element of priority queue.
TC for creating Priority Queue by initialising with collections - O(n) else it will be O(nlogn) as we insert elemnets one by one.

reverse Order -
PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());
PriorityQueue<Integer> pq = new PriorityQueue<>((a, b)->(b-a));
To create a minheap from all elements of arr[], add all elements to priorityQueue. To make a maxHeap, add -ve of all elements to priorityQueue. 

class MinHeap{
  int[] heapArr;
  int heapSize;

  MinHeap(int capacity){
    heapArr = new int[capacity];
    heapSize = 0;
  }

  public int getParent(int idx){
    return (idx-1)/2;
  }

  public int getLeftChild(int idx) return 2*idx+1;
  public int getRightChild(int idx) return 2*idx+2;

  public void shiftUp(int idx){
    int parentIdx = parent(idx);
    if(parentIdx < 0) return;
    if(heapArr[parentIdx] > heapArr[idx]){
        swap(parentIdx, idx);
        shiftUp(parentIdx);
    }
  }

  public void shiftUp(int idx){
    int parentIdx = parent(idx);
    while(parentIdx>=0 && heapArr[parentIdx]>heapArr[idx]){
        swap(parentIdx, idx);
        idx = parentIdx;
    }
  }

  public void shiftDown(int idx){
    int minIdx = idx;
    int leftChild = 2*idx+1;
    int rightChild = 2*idx+2;
    while(true){
        if(leftChild<heapSize && heapArr[leftChild]<heapArr[minIdx]){
            swap(minIdx, leftChild);
            minIdx = leftChild);
        }
        if(rightChild<heapSize && heapArr[rightChild]<heapArr[minIdx]){
            swap(minIdx, rightChild);
            minIdx = rightChild;
        }
        if(minIdx == idx) break;
        swap(minIdx, idx);
        idx = minIdx;
      }
      return;
    }

  public void shiftDown(int idx){
    int minIdx = idx;
    int leftChild = 2*idx+1;
    int rightChild = 2*idx+2;
    if(leftChild<heapSize && heapArr[leftChild]<heapArr[minIdx]){
          swap(minIdx, leftChild);
          minIdx = leftChild);
      }
      if(rightChild<heapSize && heapArr[rightChild]<heapArr[minIdx]){
          swap(minIdx, rightChild);
          minIdx = rightChild;
      }
    if(minIdx != idx){
        swap(minIdx, idx);
        shiftDown(minIdx);
    }
  }

  public void insert(int val){
    heapArr[heapSize] = val;
    heapSize += 1;
    shiftUp(heapSize-1);
  }

  public int extractMin(){
    int minVal = heapArr[0];
    heapArr[0] = heapArr[heapSize-1];
    heapSize -= 1;
    shiftDown(0);
    return minVal;
  }

  //extract min is deleting element at index 0.
  public void delete(int idx){
      heapArr[idx] = heapArr[heapSize-1];
      heapSize -= 1;
      shiftDown(idx);
  }
}

create heap from arr - TC - O(n)
From non-leaf nodes, from end of array, keep calling shiftDown/ Heapify. 
for(int i=n/2-1; i>=0; i++) shiftDown(i); //parent of last leaft node(n-1) is n/2-1;

heapSort - TC - O(n)
Create a minHeap from arr - O(n)
keep extracing min till heap becomes empty - O(nlogn)

Check if array represent minHeap - Loop through arr, for each element, check if it is lower than its children.

kth smallest/ largest number in an array, in a stream -
For kth smaller element, use maxHeap
For kth larger element, use minHeap of k size. If element > min of minHeap, remove min and add it to the heap. 
class Solution {
  public int findKthLargest(int[] nums, int k) {
      PriorityQueue<Integer> pq = new PriorityQueue<>(k);
      for(int i=0; i<k; i++){
          pq.add(nums[i]);
      }
      for(int i=k; i<nums.length; i++){
          int min = pq.peek();
          if(nums[i]>min){
              pq.poll();
              pq.add(nums[i]);
          }
      }
      return pq.peek();
  }
}

Sort k sorted lists - O(k^2logk) where k*k are the total number of elements.
1.Put first element of each array in priority queue.
2.In each iteration, remove the min element. If there exists more elements in the same row, add them to heap.
3.Heap size will be O(k).
class Pair{
    int i;
    int j;
    Pair(int i, int j){
        this.i = i;
        this.j = j;
    }
}
class Solution
{
    public static ArrayList<Integer> mergeKArrays(int[][] arr,int K) 
    {
        ArrayList<Integer> ans = new ArrayList<>();
        Comparator<Pair> comp = (a,b)->(arr[a.i][a.j]-arr[b.i][b.j]);
        PriorityQueue<Pair> pq = new PriorityQueue<>(K, comp);
        for(int i=0; i<K; i++){
            pq.add(new Pair(i, 0));
        }
        while(!pq.isEmpty()){
            Pair min = pq.poll();
            ans.add(arr[min.i][min.j]);
            if(min.j+1<K) pq.add(new Pair(min.i, min.j+1));
        }
        return ans;
    }
}

Merge k sorted linked lists -
*Before adding to priority queue, check that it is not null.
*Use dummy node as head sicen we have to create new linked list and at the end, return dummy.next.
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        ListNode head = new ListNode(-1);
        ListNode temp = head;
        Comparator<ListNode> comp = (a, b)->(a.val-b.val);
        PriorityQueue<ListNode> pq = new PriorityQueue<>(comp);
        for(int i=0; i<lists.length; i++){
            if(lists[i] != null) pq.add(lists[i]);
        }
        while(!pq.isEmpty()){
            ListNode min = pq.poll();
            temp.next = min;
            temp = temp.next;
            if(min.next != null) pq.add(min.next);
        }
        return head.next;
    }
}
median in an array, in a stream (median of odd numbers is at index n/2, median of even numbers is at index n/2, n/2+1)
