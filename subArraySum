subArray sum - sliding window, subsequence sum - DP

2 types -
1.Find longest subArray whose sum = k 
2.Find count of subArrays whose sum = k

How to solve it depends on the range of array values.
#########################################################################################################
Find maxLen of subArray whose sum is k
#########################################################################################################
Brute force -

case-1: To find maxLen if array values are positive (>0), case-2: if array values are positive and 0
class Solution {
    public int lenOfLongestSubarr(int[] arr, int k) {
        int l = 0;
        int r = 0;
        int maxLen = 0;
        int sum = 0;
        while(r<arr.length){
            sum += arr[r];
            while(sum > k){
                sum -= arr[l];
                l += 1;
            }
            if(sum==k) maxLen = Math.max(maxLen, r-l+1);
            r += 1;
        }
        return maxLen;
    }
}

case-3: if array values are positives, 0, negatives

case-1: sliding window two pointer
case-2: sliding window two pointer - calculate for <=k and <=k-1
case-3: Take map. Take map with val & count 


#####
Find length of subArray with max. sum - Kadane's algorithm 
If all positives and zeroes, total sum of array is the max sum

#####
TC - O(N * log(sum(arr)-max(arr)))
Given an integer array nums and an integer k, split nums into k non-empty subarrays such that the largest sum of any subarray is minimized.
Return the minimized largest sum of the split.A subarray is a contiguous part of the array.

class Solution {
    public int partitionCount(int[] nums, int maxSumAllowed){
        int currSum = 0;
        int partitionCount = 0;
        for(int num: nums){
            if(currSum+num <= maxSumAllowed){
                currSum += num;
            }else{
                partitionCount += 1;
                currSum = num;
            }
        }
        if(currSum <= maxSumAllowed){
            partitionCount += 1;
        }
        return partitionCount;
    }
    public int splitArray(int[] nums, int k) {
      int maxVal = 0;
      int sum = 0;
      for(int num: nums){
        maxVal = Math.max(maxVal, num);
        sum += num;
      }
      int low =  maxVal;
      int high = sum;
      while(low <= high){
        int mid = low+(high-low)/2;
        if(partitionCount(nums, mid)>k) low=mid+1;
        else high = mid-1;
      }
      return low;
    }
}

