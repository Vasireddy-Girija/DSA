When to think if this can be solved using binary seach - 
Sorted Array - search for element, firstOccurrence, lastOccurrence, number of occurrences
Rotated sorted array - search for element in unique, search for element in duplicates, min element in unique, how many times arr was rotated.
Time Complexity - log(n)
Max or min (binary search on answers)

In binary search, for every iteration, we should be able to lower the search space by half. This yields to logn time complexity.
low=0, high=n-1, mid=low+(high-low)/2. mid is calculated this way so that it doesn't overflow where high+low can be more than Integer.MAX_VALUE.

while returning ans, if the condition for mid has mid-1 and mid+1, handle cases for 0,n-1 separately and start binary search from 
low = 1 and high=n-2. Similiar to problems in find single element and peak element.

Binary Search algo - O(logn)
class Solution {
    public int search(int[] nums, int target) {
        int low = 0;
        int high = nums.length-1;
        while(low <= high){
            int mid = low+(high-low)/2;
            if(nums[mid]==target) return mid;
            if(nums[mid]>target) high=mid-1;
            else low = mid+1;
        }
        return -1;
    }
}

Find floor and ceil - In binary search also, return high at the end for floor and return low for ceil.
If num don't exist, based on the search key, low can go to n and high can go to -1 and stop.

Find the first and last occurrence of an element in sorted array-
First find firstOccurrence. If firstOccurrence idx is in bounds and its value is same as target
(i.e atleast one element which is same sa target is present in the array), then find lastOccurrence.
Note- Since we are not returning when we find idx whaose value is target, use if else-if else and not if if else.
class Solution {
    public int firstOccurrenceIdx(int[] arr, int target){
        int low = 0;
        int high = arr.length-1;
        while(low<=high){
            int mid = low+(high-low)/2;
            if(arr[mid]==target) high=mid-1;
            else if(arr[mid]>target) high=mid-1;
            else low=mid+1;
        }
        return low;
    }
    public int lastOccurrenceIdx(int[] arr, int target){
        int low = 0;
        int high = arr.length-1;
        while(low <= high){
            int mid = low+(high-low)/2;
            if(arr[mid]==target) low=mid+1;
            else if(arr[mid]>target) high=mid-1;
            else low=mid+1;
        }
        return high;
    }
    public int[] searchRange(int[] nums, int target) {
        int firstOccurrenceIdx = firstOccurrenceIdx(nums, target);
        if(firstOccurrenceIdx < 0 || firstOccurrenceIdx == nums.length) return new int[]{-1,-1};
        if(nums[firstOccurrenceIdx] != target) return new int[]{-1, -1};
        int lastOccurrenceIdx = lastOccurrenceIdx(nums, target);
        return new int[]{firstOccurrenceIdx, lastOccurrenceIdx};
    }
}

Count num of occurrences of element in sorted array - find firstOccurrence, do checks, if valid, find lastOccurrence.
ans will be lastOccurrence-firstOccurrence+1;

Rotated sorted array -
1.Distinct values -
class Solution {
    public int search(int[] nums, int target) {
        int low = 0;
        int high = nums.length-1;
        while(low <= high){
            int mid = low+(high-low)/2;
            if(target==nums[mid]) return mid;
            //left side is sorted
            if(nums[low]<=nums[mid]){
                if(target>=nums[low] && target<nums[mid]) high=mid-1;
                else low=mid+1;
            //right side is sorted
            }else if(nums[high]>=nums[mid]){
                if(target>nums[mid] && target<=nums[high]) low=mid+1;
                else high=mid-1;
            }
        }
        return -1;
    }
}

2.Duplicate values -
If low, high, mid values all are equal, we will not know which part is sorted.
Example - [2,2,2,4,2], [2,4,2,2,2]. So remove elements from left, right until they are mid==low==high doesn't hold true.
Example - [2,3,4,5,2] - Even if low and high are same, but mid is not equal to that, we'll be able to say which part is sorted.
Avg. time complexity - O(logn)
Worst case time complexity - O(N/2) for arr=[3,3,3,3,3] and target=2.
class Solution {
    public boolean search(int[] nums, int target) {
        int n = nums.length;
        int low =0; 
        int high = n-1;
        while(low <= high){
            int mid = low+(high-low)/2;
            if(nums[mid]==target) return true;
            if(nums[low]==nums[mid] && nums[high]==nums[mid]){
                low += 1;
                high -= 1;
                continue;
            }
            if(nums[low]<=nums[mid]){
                if(target>=nums[low] && target<nums[mid]) high=mid-1;
                else low=mid+1;
            }else if(nums[high]>=nums[mid]){
                if(target>nums[mid] && target<=nums[high]) low=mid+1;
                else high=mid-1;
            }
        }
        return false;
    }
}

3.Find min in rotated sorted array - TC - O(logn)
Min element will be less than its left and right element if it has unique elements.
For unique elements, if arr[low]<=arr[high], then arr[low] will be min. (or eual to case covers when low is same as high)
if left half is sorted, take min element and search in right half.
if right half is sorted, take min element and search in left half.
class Solution {
    public int findMin(int[] nums) {
        int ans = Integer.MAX_VALUE;
        int low=0;
        int high=nums.length-1;
        while(low<=high){
            int mid = low+(high-low)/2;
            if(nums[low]<=nums[high]){
                ans = Math.min(ans, nums[low]);
                break;
            }
            if(nums[low]<=nums[mid]){
                ans = Math.min(ans, nums[low]);
                low = mid+1;
            }else if(nums[mid]<=nums[high]){
                ans = Math.min(ans, nums[mid]);
                high = mid-1;
            }
        }
        return ans;
    }
}

To find how many times, sorted arr is rotated, find index of min element.
Take ansIdx along with ans. Keep updating ansIdx when ans is updated.
If arr is right rotated, ansIdx is the ans. If arr is left rotated, n-ansIdx will be the number of left rotations.

Single element in a sorted array - This array has every element 2 times except one element. Find that one element.
public class tUf {
    public static int singleNonDuplicate(ArrayList<Integer> arr) {
        int n = arr.size(); // Size of the array.

        // Edge cases:
        if (n == 1)
            return arr.get(0);
        if (!arr.get(0).equals(arr.get(1)))
            return arr.get(0);
        if (!arr.get(n - 1).equals(arr.get(n - 2)))
            return arr.get(n - 1);

        int low = 1, high = n - 2;
        while (low <= high) {
            int mid = (low + high) / 2;

            // If arr[mid] is the single element:
            if (!arr.get(mid).equals(arr.get(mid + 1)) && !arr.get(mid).equals(arr.get(mid - 1))) {
                return arr.get(mid);
            }

            // We are in the left:
            if ((mid % 2 == 1 && arr.get(mid).equals(arr.get(mid - 1)))
                    || (mid % 2 == 0 && arr.get(mid).equals(arr.get(mid + 1)))) {
                // Eliminate the left half:
                low = mid + 1;
            }
            // We are in the right:
            else {
                // Eliminate the right half:
                high = mid - 1;
            }
        }

        // Dummy return statement:
        return -1;
    }

Find peak element - find an element where it is strictly greater than its neighbours.
Imp condition - nums[i] != nums[i + 1] for all valid i. - So we can eliminate one half every time. 
If nums[i]==nums[i+1], we will not be sure which side to go.
4 changes - mid can be peak, can be in increasing trend, can be in decreasing trend, can be min peak.
class Solution {
    public int findPeakElement(int[] nums) {
        int n = nums.length;
        if(n==1) return 0;
        if(nums[0]>nums[1]) return 0;
        if(nums[n-1]>nums[n-2]) return n-1;

        int low = 1;
        int high = n-2;
        while(low <= high){
            int mid = low + (high-low)/2;
            if(nums[mid]>nums[mid-1] && nums[mid]>nums[mid+1]) return mid;
            if(nums[mid]>nums[mid-1]) low = mid+1;
            if(nums[mid]>nums[mid+1]) high = mid-1;
            if(nums[mid]<nums[mid-1] && nums[mid]<nums[mid+1]) high = mid-1; //we can go to any half.
        }
        return -1;
    }
}

######################################################################################################################
