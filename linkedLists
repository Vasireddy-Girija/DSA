elements in array are continuous
elements in linked lists are non-continuous

class Node{
  int data;
  Node next;
  Node(int data, Node next){
    this.data = data;
    this.next = next;
  }
}
base case - if(head==null) return;

Search for an element - O(n)
Length of linked list - O(n)

############################################################################################
Delete head - O(1) head=head.next;

Delete tail - O(n)
  if(head==null || head.next==null) return null;
  Node temp = head;
  while(temp.next.next!=null){
      temp = temp.next;
  }
  temp.next = null;

Delete kth element - O(k)
  if(k==1){
    head = head.next;
    return head;
  }
  Node temp = head; Node prev=null;
  int cnt=1;
  while(temp != null){
    if(cnt == k){
        prev.next = temp.next;
        return head;
    }
    prev = temp;
    temp = temp.next;
    cnt += 1;
  }
  return head;

Delete element val - O(n) - same as above

Delete middle element - Find middle element by using fast, slow pointers.

############################################################################################
Insert head - O(1) return head = new Node(data);

Insert tail - O(n)
if(head == null) return head=new Node(data);
Node temp = head; Node prev = null;
while(temp != null){
  prev = temp;
  temp = temp.next;
}
prev.next = new Node(data);
return head;

Insert at kth position - O(k)
Node newNode = new Node(data);
if(k==1){
  newNode.next = head;
  return temp;
}
Node temp = head; Node prev =  null; int cnt=1;
while(temp != null){
  if(cnt == k){
    prev.next = newNode;
    newNode.next = temp;
    return head;
  }
  prev = temp;
  temp = temp.next;
  cnt += 1;
}
if(cnt == k){
    prev.next = newNode;
}
return head;

############################################################################################
Reverse a linked list -

############################################################################################
Tortoise-hare method -
1.Find middle element in a linked list
class Solution {
    public ListNode middleNode(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        while(fast!=null && fast.next!=null){
            fast = fast.next.next;
            slow = slow.next;
        }
        return slow;
    }
}

2.Check if there is a cycle in linked-list
public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        while(fast != null && fast.next != null){
            fast = fast.next.next;
            slow = slow.next;
            if(slow == fast) return true;
        }
        return false;
    }
}

