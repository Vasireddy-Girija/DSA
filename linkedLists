elements in array are continuous
elements in linked lists are non-continuous

class Node{
  int data;
  Node next;
  Node(int data, Node next){
    this.data = data;
    this.next = next;
  }
}
base case - if(head==null) return;

Search for an element - O(n)
Length of linked list - O(n)

############################################################################################
Delete head - O(1) head=head.next;

Delete tail - O(n)
  if(head==null || head.next==null) return null;
  Node temp = head;
  while(temp.next.next!=null){
      temp = temp.next;
  }
  temp.next = null;

Delete kth element - O(k)
  if(k==1){
    head = head.next;
    return head;
  }
  Node temp = head; Node prev=null;
  int cnt=1;
  while(temp != null){
    if(cnt == k){
        prev.next = temp.next;
        return head;
    }
    prev = temp;
    temp = temp.next;
    cnt += 1;
  }
  return head;

Delete element val - O(n) - same as above

Delete middle element - Find middle element by using fast, slow pointers.

############################################################################################
Insert head - O(1) return head = new Node(data);

Insert tail - O(n)
if(head == null) return head=new Node(data);
Node temp = head; Node prev = null;
while(temp != null){
  prev = temp;
  temp = temp.next;
}
prev.next = new Node(data);
return head;

Insert at kth position - O(k)
Node newNode = new Node(data);
if(k==1){
  newNode.next = head;
  return temp;
}
Node temp = head; Node prev =  null; int cnt=1;
while(temp != null){
  if(cnt == k){
    prev.next = newNode;
    newNode.next = temp;
    return head;
  }
  prev = temp;
  temp = temp.next;
  cnt += 1;
}
if(cnt == k){
    prev.next = newNode;
}
return head;

############################################################################################
Reverse a linked list -
Iterative - Point curr.next to prev, before that keep saving curr.next.
class Solution {
    public ListNode reverseList(ListNode head) {
        if(head==null || head.next==null) return head;
        ListNode prev=null;
        ListNode curr=head;
        while(curr != null){
            ListNode next = curr.next;
            curr.next = prev;
            prev = curr;
            curr = next;
        }
        return prev;
    }
}

Sort a linked list -
############################################################################################
Tortoise-hare method -
1.Find middle element in a linked list
class Solution {
    public ListNode middleNode(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        while(fast!=null && fast.next!=null){
            fast = fast.next.next;
            slow = slow.next;
        }
        return slow;
    }
}

2.Check if there is a cycle in linked-list
public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        while(fast != null && fast.next != null){
            fast = fast.next.next;
            slow = slow.next;
            if(slow == fast) return true;
        }
        return false;
    }
}

3.Find length of loop - 
We should need one Node which is part of loop. Once we get it, iterate till we get it to count.
How to get one element from loop - slow == fas, slow will be one element in a loop.
class Solution {
    public int countNodesinLoop(Node head) {
        Node slow = head;
        Node fast = head;
        while(fast!=null && fast.next!=null){
            fast = fast.next.next;
            slow = slow.next;
            if(fast == slow) break;
        }
        if(fast==null || fast.next==null) return 0;
        int cnt=1;
        Node next = fast.next;
        while(next != slow){
            cnt += 1;
            next = next.next;
        }
        return cnt;
    }
}

4.Find starting point of loop - 
How ? 
a)find slow == fast pointer. Set slow pointer to head and pointer. Now move slow and fast poiner by one step. 
When slow and fast pointer meets again, that will be starting point.
Intuition -
Let length from head to startPoint of loop be l.
When slow pointer moves l, fast pointer moves 2l, out of which l is inside loop.
Let the total distance of loop - l+d.
After this step, for each turn, slow moves 1 pointer and fast moves 2 pointers. Difference between slow and fast will be d-1.
After d steps, they'll meet.
Now slow and fast pointer will be d steps from starting point.
public class Solution {
    public ListNode startNode(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        while(fast != null && fast.next != null){
            fast = fast.next.next;
            slow = slow.next;
            if(fast == slow){
                slow = head;
                while(fast != slow){
                    slow = slow.next;
                    fast = fast.next;
                }
                return slow;
            }
        }
        return null;
    }
}
